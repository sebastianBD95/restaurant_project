name: Build and Deploy Backend

on:
  workflow_dispatch:
  push:
    tags:
      - "restaurant_manager/v*"
    paths:
      - "restaurant_manager/**"
      - ".github/workflows/deploy-backend.yml"

jobs:
  build:
    name: Build and Push to ECR
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    env:
      ECR_REPOSITORY: restaurant-app-dev-backend
      IMAGE_TAG: ${{ github.ref_name }}
    outputs:
      image: ${{ steps.build-image.outputs.image }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push image to Amazon ECR
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ env.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
        run: |
          # Convert tag format from restaurant_manager/v0.0.0 to restaurant_manager_v0.0.0
          DOCKER_TAG=$(echo $IMAGE_TAG | sed 's/restaurant_manager\//restaurant_manager_/')
          # Build a docker container for ARM64 and push it to ECR
          docker build --platform linux/arm64 -t $ECR_REGISTRY/$ECR_REPOSITORY:$DOCKER_TAG .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$DOCKER_TAG
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$DOCKER_TAG" >> $GITHUB_OUTPUT
          echo "Built image: $ECR_REGISTRY/$ECR_REPOSITORY:$DOCKER_TAG"

  deploy:
    name: Deploy to EC2
    needs: build
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Copy deployment files to EC2
        run: |
          # Create deployment files content
          cat > docker-compose.production.yaml << 'EOF'
          version: "3.9"
          
          services:
            restaurant-manager:
              image: ${ECR_REGISTRY}/restaurant-app-dev-backend:${IMAGE_TAG}
              container_name: restaurant-manager
              restart: unless-stopped
              expose:
                - "8080"
              environment:
                - APP_ENV=prod
                - DATABASE_URL=${DATABASE_URL}
                - JWT_PRIVATE_KEY_PATH=/usr/local/bin/resources/private.key
                - JWT_PUBLIC_KEY_PATH=/usr/local/bin/resources/public.key
                - AWS_PROFILE=${AWS_PROFILE}
                - AWS_REGION=${AWS_REGION}
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 40s
              networks:
                - app-network
          
            caddy:
              image: caddy:2-alpine
              container_name: caddy-proxy
              restart: unless-stopped
              ports:
                - "80:80"
                - "443:443"
              volumes:
                - ./Caddyfile:/etc/caddy/Caddyfile:ro
                - caddy_data:/data
                - caddy_config:/config
              depends_on:
                - restaurant-manager
              networks:
                - app-network
          
          volumes:
            caddy_data:
            caddy_config:
          
          networks:
            app-network:
              driver: bridge
          EOF
          
          cat > Caddyfile << 'EOF'
          # Caddyfile for Restaurant Manager API
          api.servu.com.co {
              # Reverse proxy to the Go application
              reverse_proxy restaurant-manager:8080 {
                  # Health check
                  health_uri /health
                  health_interval 30s
                  health_timeout 10s
                  health_status 200
              }
          
              # Logging
              log {
                  output file /var/log/caddy/api.log
                  format json
              }
          
              # Security headers
              header {
                  # Remove server header
                  -Server
                  # Security headers
                  X-Content-Type-Options nosniff
                  X-Frame-Options DENY
                  X-XSS-Protection "1; mode=block"
                  Referrer-Policy strict-origin-when-cross-origin
                  # CORS headers for API
                  Access-Control-Allow-Origin *
                  Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS"
                  Access-Control-Allow-Headers "Content-Type, Authorization"
              }
          
              # Handle preflight requests
              @options {
                  method OPTIONS
              }
              respond @options 200 {
                  header Access-Control-Allow-Origin *
                  header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS"
                  header Access-Control-Allow-Headers "Content-Type, Authorization"
              }
          }
          EOF
          
          # Upload to S3 for deployment
          aws s3 cp docker-compose.production.yaml s3://${{ secrets.MIGRATIONS_BUCKET }}/deployment/docker-compose.production.yaml
          aws s3 cp Caddyfile s3://${{ secrets.MIGRATIONS_BUCKET }}/deployment/Caddyfile

      - name: Build SSM deployment command JSON
        id: build
        shell: bash
        run: |
          # Debug: Print the image variable
          echo "Image from build job: ${{ needs.build.outputs.image }}"
          
          # Fallback: Construct image name if output is empty
          if [ -z "${{ needs.build.outputs.image }}" ]; then
            DOCKER_TAG=$(echo ${{ github.ref_name }} | sed 's/restaurant_manager\//restaurant_manager_/')
            IMAGE_NAME="${{ steps.login-ecr.outputs.registry }}/restaurant-app-dev-backend:$DOCKER_TAG"
            echo "Using fallback image name: $IMAGE_NAME"
          else
            IMAGE_NAME="${{ needs.build.outputs.image }}"
            echo "Using build job output: $IMAGE_NAME"
          fi
          
          # Extract registry and tag from image name
          ECR_REGISTRY=$(echo $IMAGE_NAME | cut -d'/' -f1)
          IMAGE_TAG=$(echo $IMAGE_NAME | cut -d':' -f2)
          
          # Create JSON file for deployment command
          cat > deploy.json << EOF
          {
            "commands": [
              "bash -lc 'set -euo pipefail; echo \"Starting deployment...\"; aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | docker login --username AWS --password-stdin ${{ steps.login-ecr.outputs.registry }}; echo \"Pulling image: $IMAGE_NAME\"; docker pull \"$IMAGE_NAME\"; mkdir -p /opt/restaurant-manager; cd /opt/restaurant-manager; aws s3 cp s3://${{ secrets.MIGRATIONS_BUCKET }}/deployment/docker-compose.production.yaml .; aws s3 cp s3://${{ secrets.MIGRATIONS_BUCKET }}/deployment/Caddyfile .; echo \"ECR_REGISTRY=$ECR_REGISTRY\" > .env; echo \"IMAGE_TAG=$IMAGE_TAG\" >> .env; echo \"DATABASE_URL=${{ secrets.DATABASE_URL }}\" >> .env; echo \"AWS_PROFILE=${{ secrets.AWS_PROFILE }}\" >> .env; echo \"AWS_REGION=${{ secrets.AWS_REGION }}\" >> .env; echo \"APP_ENV=prod\" >> .env; docker-compose -f docker-compose.production.yaml down || true; docker-compose -f docker-compose.production.yaml up -d; docker-compose -f docker-compose.production.yaml ps'"
            ]
          }
          EOF

      - name: Deploy to EC2
        id: deploy
        run: |
          CMD_ID=$(aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --instance-ids "${{ secrets.EC2_INSTANCE_ID }}" \
            --comment "Deploy backend $GITHUB_SHA" \
            --parameters file://deploy.json \
            --query 'Command.CommandId' \
            --output text)
          echo "cmd_id=$CMD_ID" >> "$GITHUB_OUTPUT"

      - name: Wait for deployment completion
        run: aws ssm wait command-executed --command-id "${{ steps.deploy.outputs.cmd_id }}" --instance-id "${{ secrets.EC2_INSTANCE_ID }}"

      - name: Report deployment status
        run: |
          aws ssm get-command-invocation \
            --command-id "${{ steps.deploy.outputs.cmd_id }}" \
            --instance-id "${{ secrets.EC2_INSTANCE_ID }}" \
            --query 'Status' --output text

      - name: Health check
        run: |
          sleep 10
          curl -f http://${{ secrets.EC2_INSTANCE_ID }}/health || echo "Health check failed"
