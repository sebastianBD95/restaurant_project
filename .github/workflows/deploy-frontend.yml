name: Frontend Deploy
on:
  workflow_dispatch:
  push:
    tags:
      - "restaurant_front/v*"
    paths:
      - "restaurant_front/**"
      - "package*.json"
      - ".github/workflows/deploy-frontend.yml"

jobs:
  build:
    runs-on: ubuntu-latest
    permissions: { id-token: write, contents: read }
    outputs:
      image: ${{ steps.build-image.outputs.image }}
      registry: ${{ steps.login-ecr.outputs.registry }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
        

      - name: Build, tag, and push image to Amazon ECR
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: restaurant-app-dev-backend
          IMAGE_TAG: ${{ github.ref_name }}
        run: |
          cd restaurant_front
          
          # Convert tag format (restaurant_front/v1.0.0 -> restaurant_front_v1.0.0)
          DOCKER_TAG=$(echo $IMAGE_TAG | sed 's/restaurant_front\//restaurant_front_/')
          
          # Build the Docker image
          docker build --platform linux/amd64 -t $ECR_REGISTRY/$ECR_REPOSITORY:$DOCKER_TAG .
          
          # Push the image
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$DOCKER_TAG
          
          # Output the full image name
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$DOCKER_TAG" >> $GITHUB_OUTPUT

      - name: Copy deployment files to EC2
        run: |
          # Upload to S3 for deployment
          aws s3 cp docker-compose.production.yaml s3://${{ secrets.MIGRATIONS_BUCKET }}/deployment/docker-compose.production.yaml  
          aws s3 cp Caddyfile s3://${{ secrets.MIGRATIONS_BUCKET }}/deployment/Caddyfile

  deploy:
    needs: build
    runs-on: ubuntu-latest
    permissions: { id-token: write, contents: read }
    steps:
      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ secrets.AWS_REGION }}


      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Get latest backend image tag
        id: get-backend-tag
        run: |
          # List all tags sorted by push time and pick the latest backend tag only
          IMAGE_TAG_BACKEND=$(aws ecr describe-images \
            --repository-name restaurant-app-dev-backend \
            --query "sort_by(imageDetails,&imagePushedAt)[].imageTags[]" \
            --output text | tr '\t' '\n' | grep '^restaurant_manager_' | tail -n 1)

          if [ -z "$IMAGE_TAG_BACKEND" ]; then
            echo "ERROR: Could not find a backend tag (prefix: restaurant_manager_) in repository restaurant-app-dev-backend" >&2
            exit 1
          fi

          echo "Latest backend tag: $IMAGE_TAG_BACKEND"
          echo "backend_tag=$IMAGE_TAG_BACKEND" >> $GITHUB_OUTPUT

      - name: Build SSM deployment command JSON
        id: build
        shell: bash
        run: |
          # Debug: Print the image variable
          echo "Image from build job: ${{ needs.build.outputs.image }}"

          # Fallback: Construct image name if output is empty
          if [ -z "${{ needs.build.outputs.image }}" ]; then
            DOCKER_TAG=$(echo ${{ github.ref_name }} | sed 's/restaurant_front\//restaurant_front_/')
            IMAGE_NAME="${{ steps.login-ecr.outputs.registry }}/restaurant-app-dev-backend:$DOCKER_TAG"
            echo "Using fallback image name: $IMAGE_NAME"
          else
            IMAGE_NAME="${{ needs.build.outputs.image }}"
            echo "Using build job output: $IMAGE_NAME"
          fi

          # Extract registry and tag from image name
          ECR_REGISTRY=$(echo "$IMAGE_NAME" | cut -d'/' -f1)
          IMAGE_TAG_FRONTEND=$(echo "$IMAGE_NAME" | cut -d':' -f2)
          IMAGE_TAG_BACKEND="${{ steps.get-backend-tag.outputs.backend_tag }}"

          # Create JSON file for deployment command
          cat > deploy-frontend.json << EOF
          {
            "commands": [
              "bash -lc 'set -euo pipefail; \
               echo \"Starting frontend deployment...\"; \
               aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | docker login --username AWS --password-stdin $ECR_REGISTRY; \
               echo \"Pulling frontend image: $IMAGE_NAME\"; \
               docker pull \"$IMAGE_NAME\"; \
               mkdir -p /opt/restaurant-manager; \
               cd /opt/restaurant-manager; \
               aws s3 cp s3://${{ secrets.MIGRATIONS_BUCKET }}/deployment/docker-compose.production.yaml docker-compose.yaml; \
               aws s3 cp s3://${{ secrets.MIGRATIONS_BUCKET }}/deployment/Caddyfile .; \
               echo \"ECR_REGISTRY=$ECR_REGISTRY\" > .env; \
               echo \"IMAGE_TAG_FRONTEND=$IMAGE_TAG_FRONTEND\" >> .env; \
               echo \"IMAGE_TAG_BACKEND=$IMAGE_TAG_BACKEND\" >> .env; \
               docker-compose -f docker-compose.production.yaml down || true; \
               docker-compose -f docker-compose.production.yaml up -d; \
               docker-compose -f docker-compose.production.yaml ps'"
            ]
          }
          EOF

      - name: Deploy to EC2
        id: deploy
        run: |
          CMD_ID=$(aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --instance-ids "${{ secrets.EC2_INSTANCE_ID }}" \
            --comment "Deploy frontend $GITHUB_SHA" \
            --parameters file://deploy-frontend.json \
            --query 'Command.CommandId' \
            --output text)
          echo "cmd_id=$CMD_ID" >> "$GITHUB_OUTPUT"

      - name: Wait for deployment completion
        run: aws ssm wait command-executed --command-id "${{ steps.deploy.outputs.cmd_id }}" --instance-id "${{ secrets.EC2_INSTANCE_ID }}"

      - name: Report deployment status
        run: |
          aws ssm get-command-invocation \
            --command-id "${{ steps.deploy.outputs.cmd_id }}" \
            --instance-id "${{ secrets.EC2_INSTANCE_ID }}" \
            --query 'Status' --output text
